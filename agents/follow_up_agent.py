"""
Follow-up Agent
Monitors changes and updates action plans based on user progress and changing circumstances
"""
import json
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from enum import Enum
from pydantic import BaseModel, Field
from loguru import logger

from agents.base_agent import BaseAgent


class ChangeType(str, Enum):
    """Types of changes that can occur"""
    PROFILE_UPDATE = "profile_update"
    DOCUMENT_OBTAINED = "document_obtained"
    STEP_COMPLETED = "step_completed"
    STATUS_CHANGE = "status_change"
    DEADLINE_APPROACHING = "deadline_approaching"
    SCHEME_UPDATE = "scheme_update"
    ERROR_ENCOUNTERED = "error_encountered"


class FollowUpAction(str, Enum):
    """Types of follow-up actions"""
    SEND_REMINDER = "send_reminder"
    UPDATE_PLAN = "update_plan"
    ESCALATE_ISSUE = "escalate_issue"
    PROVIDE_GUIDANCE = "provide_guidance"
    CELEBRATE_MILESTONE = "celebrate_milestone"
    REQUEST_UPDATE = "request_update"


class ProgressUpdate(BaseModel):
    """Progress update from user"""
    update_id: str
    user_id: str
    plan_id: str
    timestamp: str
    change_type: ChangeType
    description: str
    affected_steps: List[str] = Field(default_factory=list)
    new_data: Dict[str, Any] = Field(default_factory=dict)
    user_notes: str = ""


class FollowUpRecommendation(BaseModel):
    """Recommendation generated by follow-up analysis"""
    recommendation_id: str
    priority: str  # "urgent", "high", "medium", "low"
    action_type: FollowUpAction
    title: str
    description: str
    suggested_deadline: Optional[str] = None
    required_user_action: bool = True
    automated_action: bool = False
    
    # Detailed guidance
    specific_instructions: List[str] = Field(default_factory=list)
    helpful_resources: List[str] = Field(default_factory=list)
    contact_information: List[str] = Field(default_factory=list)
    
    # Impact assessment
    impact_if_ignored: str = ""
    benefits_if_completed: str = ""


class FollowUpAnalysis(BaseModel):
    """Complete follow-up analysis result"""
    analysis_id: str
    user_id: str
    plan_id: str
    scheme_name: str
    analysis_date: str
    
    # Current status
    overall_progress: float = Field(ge=0.0, le=1.0)  # 0-100% completion
    completed_steps: int
    total_steps: int
    
    # Timeline analysis
    days_since_start: int
    estimated_days_remaining: int
    on_track: bool = True
    delay_risk: str = "low"  # "low", "medium", "high"
    
    # Recommendations
    urgent_recommendations: List[FollowUpRecommendation] = Field(default_factory=list)
    standard_recommendations: List[FollowUpRecommendation] = Field(default_factory=list)
    optional_recommendations: List[FollowUpRecommendation] = Field(default_factory=list)
    
    # Motivational content
    achievements: List[str] = Field(default_factory=list)
    encouragement_message: str = ""
    next_milestone: str = ""
    
    # Adaptive suggestions
    plan_adjustments: List[str] = Field(default_factory=list)
    alternative_approaches: List[str] = Field(default_factory=list)


class FollowUpAgent(BaseAgent):
    """Agent responsible for monitoring progress and providing adaptive follow-up"""
    
    def __init__(self):
        super().__init__(
            agent_id="follow_up_agent",
            name="Follow-up Agent",
            description="Monitors user progress and provides adaptive guidance and reminders",
            capabilities=[
                "detect_profile_changes",
                "analyze_change_impact",
                "adjust_action_plan",
                "generate_follow_up_reminders",
                "track_progress",
                "provide_motivation"
            ]
        )
        
        # Progress tracking thresholds
        self.progress_thresholds = {
            "excellent": 0.9,
            "good": 0.7,
            "fair": 0.5,
            "poor": 0.3,
            "critical": 0.1
        }
        
        # Delay risk factors
        self.delay_risk_factors = {
            "document_delays": 0.3,
            "missed_deadlines": 0.4,
            "incomplete_steps": 0.2,
            "no_recent_activity": 0.3
        }
    
    def get_system_prompt(self) -> str:
        """Get system prompt for follow-up analysis"""
        return f"""You are the {self.name}, an expert AI agent specialized in monitoring user progress through government scheme applications and providing adaptive, personalized follow-up support.

Your core responsibilities:
1. Monitor user progress against action plans and timelines
2. Detect changes in user circumstances that affect eligibility or plans
3. Generate proactive reminders and guidance at optimal times
4. Adapt plans based on user feedback and changing situations
5. Provide motivational support and celebrate achievements
6. Identify potential issues before they become blockers
7. Suggest alternative approaches when primary paths face obstacles

Key Follow-up Principles:
- Be proactive but not overwhelming
- Provide context-aware, personalized guidance
- Celebrate small wins to maintain motivation
- Identify and address blockers early
- Adapt communication style to user preferences
- Balance encouragement with realistic expectations
- Focus on actionable next steps

Analysis Framework:
- Progress tracking: Compare actual vs planned timeline
- Risk assessment: Identify potential delays or issues
- Adaptive guidance: Adjust recommendations based on current situation
- Motivational support: Acknowledge achievements and provide encouragement
- Problem-solving: Suggest solutions for encountered obstacles

Communication Tone:
- Supportive and encouraging
- Clear and actionable
- Respectful of user's time and circumstances
- Professional yet empathetic
- Solution-focused

You should provide comprehensive analysis that helps users stay on track while adapting to their changing needs and circumstances."""
    
    async def process_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Process follow-up analysis request"""
        try:
            user_profile = request.get("user_profile", {})
            current_plan = request.get("action_plan", {})
            progress_updates = request.get("progress_updates", [])
            last_analysis = request.get("last_analysis", {})
            analysis_options = request.get("options", {})
            
            if not current_plan:
                return {
                    "success": False,
                    "error": "Action plan is required for follow-up analysis",
                    "analysis": None
                }
            
            logger.info(f"Performing follow-up analysis for plan: {current_plan.get('plan_id', 'Unknown')}")
            
            # Step 1: Analyze current progress
            progress_analysis = await self._analyze_current_progress(
                current_plan, progress_updates, last_analysis
            )
            
            # Step 2: Detect significant changes
            change_impact = await self._analyze_change_impact(
                user_profile, current_plan, progress_updates
            )
            
            # Step 3: Generate recommendations
            recommendations = await self._generate_recommendations(
                current_plan, progress_analysis, change_impact
            )
            
            # Step 4: Create comprehensive follow-up analysis with LLM enhancement
            enhanced_analysis = await self._create_comprehensive_analysis(
                user_profile, current_plan, progress_analysis, change_impact, recommendations
            )
            
            return {
                "success": True,
                "analysis": enhanced_analysis.dict(),
                "summary": self._generate_analysis_summary(enhanced_analysis)
            }
            
        except Exception as e:
            logger.error(f"Error in follow-up analysis: {e}")
            return {
                "success": False,
                "error": str(e),
                "analysis": None
            }
    
    async def _analyze_current_progress(self, plan: Dict[str, Any], updates: List[Dict[str, Any]], last_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze current progress against the plan"""
        
        total_steps = plan.get("total_steps", 0)
        plan_start_date = datetime.fromisoformat(plan.get("created_date", datetime.now().isoformat()))
        current_date = datetime.now()
        days_since_start = (current_date - plan_start_date).days
        
        # Count completed steps from updates
        completed_steps = 0
        for update in updates:
            if update.get("change_type") == ChangeType.STEP_COMPLETED:
                completed_steps += len(update.get("affected_steps", []))
        
        # Calculate progress percentage
        progress_percentage = (completed_steps / total_steps) if total_steps > 0 else 0.0
        
        # Determine if on track
        expected_timeline_days = self._parse_timeline_to_days(plan.get("estimated_total_time", "4 weeks"))
        expected_progress = min(1.0, days_since_start / expected_timeline_days) if expected_timeline_days > 0 else 0.0
        
        on_track = progress_percentage >= (expected_progress * 0.8)  # Allow 20% slack
        
        # Calculate remaining time
        if progress_percentage > 0:
            estimated_total_days = days_since_start / progress_percentage
            estimated_days_remaining = max(0, estimated_total_days - days_since_start)
        else:
            estimated_days_remaining = expected_timeline_days
        
        # Assess delay risk
        delay_risk = self._assess_delay_risk(progress_percentage, expected_progress, updates)
        
        return {
            "progress_percentage": progress_percentage,
            "completed_steps": completed_steps,
            "total_steps": total_steps,
            "days_since_start": days_since_start,
            "estimated_days_remaining": int(estimated_days_remaining),
            "on_track": on_track,
            "delay_risk": delay_risk,
            "expected_progress": expected_progress
        }
    
    async def _analyze_change_impact(self, profile: Dict[str, Any], plan: Dict[str, Any], updates: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Analyze impact of changes on the current plan"""
        
        significant_changes = []
        minor_changes = []
        plan_adjustments_needed = []
        
        for update in updates:
            change_type = update.get("change_type")
            impact_level = self._assess_change_impact_level(change_type, update)
            
            if impact_level == "high":
                significant_changes.append(update)
                # Determine what adjustments are needed
                adjustments = self._determine_required_adjustments(update, plan)
                plan_adjustments_needed.extend(adjustments)
            else:
                minor_changes.append(update)
        
        return {
            "significant_changes": significant_changes,
            "minor_changes": minor_changes,
            "plan_adjustments_needed": plan_adjustments_needed,
            "requires_plan_update": len(significant_changes) > 0,
            "change_summary": self._create_change_summary(updates)
        }
    
    async def _generate_recommendations(self, plan: Dict[str, Any], progress: Dict[str, Any], changes: Dict[str, Any]) -> Dict[str, List[FollowUpRecommendation]]:
        """Generate follow-up recommendations based on analysis"""
        
        urgent_recs = []
        standard_recs = []
        optional_recs = []
        
        # Progress-based recommendations
        if progress["delay_risk"] == "high":
            urgent_recs.append(FollowUpRecommendation(
                recommendation_id="urgent_001",
                priority="urgent",
                action_type=FollowUpAction.ESCALATE_ISSUE,
                title="Address Critical Delays",
                description="Your application timeline is significantly behind schedule. Immediate action required.",
                suggested_deadline=(datetime.now() + timedelta(days=2)).isoformat(),
                specific_instructions=[
                    "Review which steps are causing delays",
                    "Contact relevant offices for status updates",
                    "Consider alternative approaches for blocked steps"
                ],
                impact_if_ignored="Risk of missing scheme deadlines or losing eligibility",
                benefits_if_completed="Get back on track and maintain eligibility"
            ))
        elif progress["delay_risk"] == "medium":
            standard_recs.append(FollowUpRecommendation(
                recommendation_id="standard_001",
                priority="high",
                action_type=FollowUpAction.UPDATE_PLAN,
                title="Adjust Timeline",
                description="Consider adjusting your timeline to account for current progress",
                suggested_deadline=(datetime.now() + timedelta(days=7)).isoformat(),
                specific_instructions=[
                    "Review remaining steps and their time estimates",
                    "Identify steps that can be done in parallel",
                    "Set realistic deadlines for pending actions"
                ]
            ))
        
        # Document-related recommendations
        if progress["progress_percentage"] < 0.3:
            standard_recs.append(FollowUpRecommendation(
                recommendation_id="standard_002",
                priority="high",
                action_type=FollowUpAction.PROVIDE_GUIDANCE,
                title="Focus on Document Collection",
                description="Prioritize gathering required documents to accelerate progress",
                specific_instructions=[
                    "Complete highest priority documents first",
                    "Visit multiple offices in single trips when possible",
                    "Keep digital copies of all documents"
                ],
                benefits_if_completed="Faster progression through remaining steps"
            ))
        
        # Motivational recommendations
        if progress["completed_steps"] > 0:
            optional_recs.append(FollowUpRecommendation(
                recommendation_id="optional_001",
                priority="low",
                action_type=FollowUpAction.CELEBRATE_MILESTONE,
                title="Acknowledge Your Progress",
                description=f"You've completed {progress['completed_steps']} out of {progress['total_steps']} steps!",
                required_user_action=False,
                automated_action=True,
                benefits_if_completed="Maintain motivation and momentum"
            ))
        
        # Change-based recommendations
        if changes["requires_plan_update"]:
            urgent_recs.append(FollowUpRecommendation(
                recommendation_id="urgent_002",
                priority="urgent",
                action_type=FollowUpAction.UPDATE_PLAN,
                title="Update Action Plan",
                description="Recent changes require updates to your action plan",
                specific_instructions=[
                    "Review changed circumstances",
                    "Update eligibility assessment if needed",
                    "Modify timeline and steps accordingly"
                ]
            ))
        
        return {
            "urgent": urgent_recs,
            "standard": standard_recs,
            "optional": optional_recs
        }
    
    async def _create_comprehensive_analysis(self, profile: Dict[str, Any], plan: Dict[str, Any], progress: Dict[str, Any], changes: Dict[str, Any], recommendations: Dict[str, List]) -> FollowUpAnalysis:
        """Create comprehensive follow-up analysis with LLM enhancement"""
        
        # Generate enhanced motivational content using LLM
        motivation_prompt = self._create_motivation_prompt(profile, plan, progress, changes)
        
        llm_response = await self.generate_llm_response(
            prompt=motivation_prompt,
            structured=True,
            temperature=0.6  # Slightly higher temperature for more natural motivation
        )
        
        if llm_response["success"] and llm_response.get("is_structured"):
            motivation_content = llm_response["structured_data"]
        else:
            motivation_content = self._create_default_motivation(progress)
        
        # Create comprehensive analysis
        analysis = FollowUpAnalysis(
            analysis_id=f"analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            user_id=profile.get("user_id", "unknown"),
            plan_id=plan.get("plan_id", "unknown"),
            scheme_name=plan.get("scheme_name", "Unknown Scheme"),
            analysis_date=datetime.now().isoformat(),
            
            overall_progress=progress["progress_percentage"],
            completed_steps=progress["completed_steps"],
            total_steps=progress["total_steps"],
            
            days_since_start=progress["days_since_start"],
            estimated_days_remaining=progress["estimated_days_remaining"],
            on_track=progress["on_track"],
            delay_risk=progress["delay_risk"],
            
            urgent_recommendations=recommendations["urgent"],
            standard_recommendations=recommendations["standard"],
            optional_recommendations=recommendations["optional"],
            
            achievements=motivation_content.get("achievements", []),
            encouragement_message=motivation_content.get("encouragement_message", ""),
            next_milestone=motivation_content.get("next_milestone", ""),
            
            plan_adjustments=changes.get("plan_adjustments_needed", []),
            alternative_approaches=motivation_content.get("alternative_approaches", [])
        )
        
        return analysis
    
    def _parse_timeline_to_days(self, timeline_str: str) -> int:
        """Parse timeline string to days"""
        timeline_lower = timeline_str.lower()
        
        if "week" in timeline_lower:
            try:
                weeks = int(''.join(filter(str.isdigit, timeline_str.split()[0])))
                return weeks * 7
            except:
                return 28  # Default 4 weeks
        elif "day" in timeline_lower:
            try:
                days = int(''.join(filter(str.isdigit, timeline_str.split()[0])))
                return days
            except:
                return 30  # Default 30 days
        else:
            return 28  # Default fallback
    
    def _assess_delay_risk(self, actual_progress: float, expected_progress: float, updates: List[Dict[str, Any]]) -> str:
        """Assess delay risk based on progress and updates"""
        
        # Calculate progress gap
        progress_gap = expected_progress - actual_progress
        
        # Check for recent activity
        recent_updates = [u for u in updates if 
                         (datetime.now() - datetime.fromisoformat(u.get("timestamp", datetime.now().isoformat()))).days <= 7]
        
        # Calculate risk factors
        risk_score = 0.0
        
        if progress_gap > 0.3:  # More than 30% behind
            risk_score += 0.4
        elif progress_gap > 0.1:  # More than 10% behind
            risk_score += 0.2
        
        if len(recent_updates) == 0:  # No recent activity
            risk_score += 0.3
        
        # Check for document-related delays
        doc_issues = [u for u in updates if "document" in u.get("description", "").lower()]
        if len(doc_issues) > 0:
            risk_score += 0.2
        
        # Determine risk level
        if risk_score >= 0.6:
            return "high"
        elif risk_score >= 0.3:
            return "medium"
        else:
            return "low"
    
    def _assess_change_impact_level(self, change_type: str, update: Dict[str, Any]) -> str:
        """Assess the impact level of a change"""
        high_impact_changes = [
            ChangeType.PROFILE_UPDATE,
            ChangeType.STATUS_CHANGE,
            ChangeType.SCHEME_UPDATE,
            ChangeType.ERROR_ENCOUNTERED
        ]
        
        if change_type in high_impact_changes:
            return "high"
        elif change_type == ChangeType.DEADLINE_APPROACHING:
            return "medium"
        else:
            return "low"
    
    def _determine_required_adjustments(self, update: Dict[str, Any], plan: Dict[str, Any]) -> List[str]:
        """Determine what adjustments are needed based on an update"""
        adjustments = []
        change_type = update.get("change_type")
        
        if change_type == ChangeType.PROFILE_UPDATE:
            adjustments.append("Re-evaluate eligibility based on updated profile")
            adjustments.append("Adjust document requirements if needed")
        elif change_type == ChangeType.ERROR_ENCOUNTERED:
            adjustments.append("Identify alternative approaches for blocked steps")
            adjustments.append("Update timeline to account for delays")
        elif change_type == ChangeType.SCHEME_UPDATE:
            adjustments.append("Review updated scheme requirements")
            adjustments.append("Modify application steps if needed")
        
        return adjustments
    
    def _create_change_summary(self, updates: List[Dict[str, Any]]) -> str:
        """Create summary of recent changes"""
        if not updates:
            return "No recent changes recorded"
        
        change_counts = {}
        for update in updates:
            change_type = update.get("change_type", "unknown")
            change_counts[change_type] = change_counts.get(change_type, 0) + 1
        
        summary_parts = []
        for change_type, count in change_counts.items():
            if count == 1:
                summary_parts.append(f"1 {change_type.replace('_', ' ')}")
            else:
                summary_parts.append(f"{count} {change_type.replace('_', ' ')} updates")
        
        return "; ".join(summary_parts)
    
    def _create_motivation_prompt(self, profile: Dict[str, Any], plan: Dict[str, Any], progress: Dict[str, Any], changes: Dict[str, Any]) -> str:
        """Create prompt for motivational content generation"""
        return f"""Generate motivational and supportive content for a user working through a government scheme application:

SCHEME: {plan.get('scheme_name', 'Government Scheme')}
PROGRESS: {progress['progress_percentage']:.1%} complete ({progress['completed_steps']}/{progress['total_steps']} steps)
TIME ELAPSED: {progress['days_since_start']} days
ON TRACK: {'Yes' if progress['on_track'] else 'No'}
DELAY RISK: {progress['delay_risk']}

USER CONTEXT:
- Working through: {plan.get('scheme_name', 'scheme application')}
- Current progress indicates: {'good momentum' if progress['progress_percentage'] > 0.5 else 'getting started'}
- Recent changes: {changes.get('change_summary', 'none')}

Please provide:

1. ACHIEVEMENTS: List specific accomplishments to acknowledge (even small ones)
2. ENCOURAGEMENT_MESSAGE: Personalized, supportive message (2-3 sentences)
3. NEXT_MILESTONE: Clear description of the next major milestone to work towards
4. ALTERNATIVE_APPROACHES: If facing challenges, suggest alternative methods

Guidelines:
- Be genuinely encouraging without being overly positive
- Acknowledge the effort government processes require
- Focus on progress made and concrete next steps
- Use encouraging but professional tone
- Provide specific, actionable motivation

Respond in JSON format with these fields."""
    
    def _create_default_motivation(self, progress: Dict[str, Any]) -> Dict[str, Any]:
        """Create default motivational content if LLM fails"""
        achievements = []
        if progress["completed_steps"] > 0:
            achievements.append(f"Completed {progress['completed_steps']} important steps")
        if progress["progress_percentage"] > 0.25:
            achievements.append("Made solid progress on your application")
        if progress["on_track"]:
            achievements.append("Staying on track with your timeline")
        
        encouragement = "You're making progress on your scheme application. Government processes take time, but each step brings you closer to receiving the benefits you're eligible for."
        
        if progress["progress_percentage"] < 0.5:
            next_milestone = "Focus on completing document collection phase"
        else:
            next_milestone = "Prepare for application submission"
        
        return {
            "achievements": achievements or ["Started your scheme application journey"],
            "encouragement_message": encouragement,
            "next_milestone": next_milestone,
            "alternative_approaches": ["Consider visiting offices early in the day", "Keep multiple document copies ready"]
        }
    
    def _generate_analysis_summary(self, analysis: FollowUpAnalysis) -> str:
        """Generate human-readable analysis summary"""
        progress_emoji = "ðŸŸ¢" if analysis.overall_progress > 0.7 else "ðŸŸ¡" if analysis.overall_progress > 0.3 else "ðŸ”´"
        
        summary = f"Follow-up Analysis for {analysis.scheme_name}\n\n"
        summary += f"ðŸ“Š Progress: {progress_emoji} {analysis.overall_progress:.1%} complete\n"
        summary += f"âœ… Completed: {analysis.completed_steps}/{analysis.total_steps} steps\n"
        summary += f"â± Time: {analysis.days_since_start} days elapsed, ~{analysis.estimated_days_remaining} remaining\n"
        summary += f"ðŸŽ¯ Status: {'On track' if analysis.on_track else 'Behind schedule'}\n\n"
        
        if analysis.urgent_recommendations:
            summary += f"ðŸš¨ Urgent Actions ({len(analysis.urgent_recommendations)}):\n"
            for rec in analysis.urgent_recommendations[:2]:
                summary += f"â€¢ {rec.title}\n"
            if len(analysis.urgent_recommendations) > 2:
                summary += f"â€¢ ... and {len(analysis.urgent_recommendations) - 2} more\n"
            summary += "\n"
        
        if analysis.achievements:
            summary += f"ðŸŽ‰ Recent Achievements:\n"
            for achievement in analysis.achievements[:2]:
                summary += f"â€¢ {achievement}\n"
            summary += "\n"
        
        if analysis.encouragement_message:
            summary += f"ðŸ’ª Encouragement:\n{analysis.encouragement_message}\n\n"
        
        if analysis.next_milestone:
            summary += f"ðŸŽ¯ Next Milestone: {analysis.next_milestone}\n"
        
        return summary